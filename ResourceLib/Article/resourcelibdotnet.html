<!--------------------------------------------------------------------------->
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
 <title>File Resource Management Library (.NET)</title>
 <style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
</style>
 <link rel="stylesheet" type="text/css" href="http://www.codeproject.com/styles/global.css">
</head>
<body bgcolor="#FFFFFF" color="#000000">

<h2>Introduction</h2>

<p>There are several good articles about reading and writing resources from/to a compiled binary. Most focus on retrieving module version information and modifying version information, mostly in C++. Some detail the same operations for cursor or dialog resources. There's, however, no single .NET library to retrieve and save any type of resources, or any library to edit version resources specifically.</p>

<p>This implementation is a framework that enumerates resources and implements both read and write of the file version (<code>VS_VERSIONINFO</code>) resources. It can be easily extended to other resource types.</p>

<h2>Background</h2>

<p>Initially, I started porting the version resource implementation from <a href="VerInfoLib.aspx">Denis Zabavchik's C++ VerInfoLib</a>. Then, it grew bigger ...</p>

<h2>Using the Code</h2>

<h3>Enumerating Resources</h3>

<p>The following example demonstrates enumerating resources by type. From the sample <em>atl.dll</em> in the Windows <em>system</em> directory, you will typically get the following resources: MUI, REGISTRY, TYPELIB, and &quot;16&quot;, which is the <code>RT_VERSION</code> resource.</p>

<pre lang="cs"><span class="code-keyword">string</span> filename = Path.Combine(Environment.SystemDirectory, <span class="code-string">&quot;</span><span class="code-string">atl.dll&quot;</span>);
<span class="code-keyword">using</span> (ResourceInfo vi = <span class="code-keyword">new</span> ResourceInfo()) 
{
 vi.Load(filename);
 <span class="code-keyword">foreach</span> (<span class="code-keyword">string</span> type <span class="code-keyword">in</span> vi.ResourceTypes)
 {
  Console.WriteLine(type);
  <span class="code-keyword">foreach</span> (Resource resource <span class="code-keyword">in</span> vi.Resources[type])
  {
   Console.WriteLine(<span class="code-string">&quot;</span><span class="code-string"> {0} ({1}) - {2} byte(s)&quot;</span>, 
           resource.Name, resource.Language, resource.Size);
  }
 }
}</pre>

<h3>Reading Version Information</h3>

<p>You can load file version information without enumerating resources.</p>

<pre lang="cs"><span class="code-keyword">string</span> filename = Path.Combine(Environment.SystemDirectory, <span class="code-string">&quot;</span><span class="code-string">atl.dll&quot;</span>);
VersionResource versionResource = <span class="code-keyword">new</span> VersionResource();
versionResource.LoadFrom(filename);
Console.WriteLine(<span class="code-string">&quot;</span><span class="code-string">File version: {0}&quot;</span>, versionResource.FileVersion);
StringFileInfo stringFileInfo = 
     (StringFileInfo) versionResource[<span class="code-string">&quot;</span><span class="code-string">StringFileInfo&quot;</span>];
<span class="code-keyword">foreach</span> (KeyValuePair&lt;string, StringResource&gt; stringResource 
         <span class="code-keyword">in</span> stringFileInfo.Default.Strings)
{
 Console.WriteLine(<span class="code-string">&quot;</span><span class="code-string">{0} = {1}&quot;</span>, stringResource.Value.Key, 
                   stringResource.Value.StringValue);
}</pre>

<h3>Writing Version Information</h3>

<p>You can also write updated version information. Note that string resources should end with an extra null terminator.</p>

<pre lang="cs"><span class="code-keyword">string</span> filename = Path.Combine(Environment.SystemDirectory, <span class="code-string">&quot;</span><span class="code-string">atl.dll&quot;</span>);
VersionResource versionResource = <span class="code-keyword">new</span> VersionResource();
versionResource.LoadFrom(filename);
Console.WriteLine(<span class="code-string">&quot;</span><span class="code-string">File version: {0}&quot;</span>, versionResource.FileVersion);
versionResource.FileVersion = <span class="code-string">&quot;</span><span class="code-string">1.2.3.4&quot;</span>;
StringFileInfo stringFileInfo = (StringFileInfo) versionResource[<span class="code-string">&quot;</span><span class="code-string">StringFileInfo&quot;</span>];
stringFileInfo[<span class="code-string">&quot;</span><span class="code-string">CompanyName&quot;</span>] = <span class="code-string">&quot;</span><span class="code-string">My Company\0&quot;</span>;
stringFileInfo[<span class="code-string">&quot;</span><span class="code-string">Weather&quot;</span>] = <span class="code-string">&quot;</span><span class="code-string">Sunshine, beach weather.\0&quot;</span>; 
versionResource.SaveTo(filename);</pre>

<h2>Implementation</h2>

<h3>Base Structures</h3>

<p>Every resource structure has a similar header, implemented in <em>ResourceTable.cs</em>.</p>

<pre lang="cs">[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)] 
<span class="code-keyword">public</span> <span class="code-keyword">struct</span> RESOURCE_HEADER 
{ 
 <span class="code-keyword">public</span> <span class="code-SDKkeyword">UInt16</span> wLength; 
 <span class="code-keyword">public</span> <span class="code-SDKkeyword">UInt16</span> wValueLength; 
 <span class="code-keyword">public</span> <span class="code-SDKkeyword">UInt16</span> wType; 
};</pre>

<p>The header is usually followed by a Unicode string (a key) and an array of data structures, each with a similar resource header. All structures are aligned to 32-bit boundaries.</p>

<h3>Reading</h3>

<p>Because of a uniform type of header, you'll find the same pattern in reading structured data throughout the code.</p>

<p>Here's an example of <code>StringTable</code>:</p>

<pre lang="cs"><span class="code-keyword">public</span> <span class="code-keyword">override</span> <span class="code-SDKkeyword">IntPtr</span> Read(<span class="code-SDKkeyword">IntPtr</span> lpRes) 
{
 <span class="code-SDKkeyword">IntPtr</span> pChild = <span class="code-keyword">base</span>.Read(lpRes);
 <span class="code-keyword">while</span> (pChild.ToInt32() &lt; (lpRes.ToInt32() + _header.wLength)) 
 {
  StringResource res = <span class="code-keyword">new</span> StringResource(pChild); 
  _strings.Add(res.Key, res); 
  pChild = ResourceUtil.Align(pChild.ToInt32() + res.Header.wLength); 
 } 
 <span class="code-keyword">return</span> <span class="code-keyword">new</span> <span class="code-SDKkeyword">IntPtr</span>(lpRes.ToInt32() + _header.wLength); 
}</pre>

<p>Each <code>StringResource</code> is the endpoint structure without any children.</p>

<pre lang="cs"><span class="code-keyword">public</span> <span class="code-keyword">void</span> Read(<span class="code-SDKkeyword">IntPtr</span> lpRes) 
{ 
 _header = (Kernel32.RESOURCE_HEADER) Marshal.PtrToStructure( lpRes, 
                                      <span class="code-keyword">typeof</span>(Kernel32.RESOURCE_HEADER)); 
 <span class="code-SDKkeyword">IntPtr</span> pKey = <span class="code-keyword">new</span> <span class="code-SDKkeyword">IntPtr</span>(lpRes.ToInt32() + Marshal.SizeOf(_header)); 
 _key = Marshal.PtrToStringUni(pKey); 
 <span class="code-SDKkeyword">IntPtr</span> pValue = ResourceUtil.Align(pKey.ToInt32() + (_key.Length + <span class="code-digit">1</span>) * <span class="code-digit">2</span>); 
 _value = _header.wValueLength &gt; <span class="code-digit">0</span> ? Marshal.PtrToStringUni(pValue, 
                                        _header.wValueLength) : <span class="code-keyword">null</span>; 
}</pre>

<h3>Writing</h3>

<p>Writing is the reverse operation of reading, but the header must be updated to the correct length. It's easier to align the structure and to calculate the difference between the end of the structure and the beginning of it after it's written.</p>

<pre lang="cs"><span class="code-keyword">public</span> <span class="code-keyword">override</span> <span class="code-keyword">void</span> Write(BinaryWriter w) 
{ 
 <span class="code-keyword">long</span> headerPos = w.BaseStream.Position; 
 <span class="code-keyword">base</span>.Write(w); 
 Dictionary&lt;string /&gt;.Enumerator stringsEnum = _strings.GetEnumerator(); 
 <span class="code-keyword">while</span> (stringsEnum.MoveNext()) 
 { 
  stringsEnum.Current.Value.Write(w); 
 } 
 ResourceUtil.PadToDWORD(w); 
 ResourceUtil.WriteAt(w, w.BaseStream.Position - headerPos, headerPos); 
}</pre>

<h2>Source Code</h2>

<p>The latest version of this article and source code can always be found <a href="svn://svn.vestris.com/codeproject/ResourceLib/" target="_blank">here</a>.</p>

<h2>Links</h2>

<p>This article combines, implements, ports, or obsoletes the functionalities of the following publications:</p>

<ul>
<li><a href="VerInfoLib.aspx">Modification of Version Information Resources in Compiled Binaries</a></li>

<li><a href="http://www.codeproject.com/KB/cpp/GetLocalVersionInfos.aspx">Retrieving version information from your local application's resource</a></li>

<li><a href="http://www.codeproject.com/KB/dotnet/FastFileVersion.aspx">A Fast Way to Get at the File's Version</a></li>
</ul>

<h2>History</h2>

<ul>
<li>2008-06-30: Initial version</li>
 <li>2008-07-08: Bug: wrong value for RT_RCDATA</li>
</ul>


</body>
</html>
