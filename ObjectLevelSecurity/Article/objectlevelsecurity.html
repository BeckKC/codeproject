<!--------------------------------------------------------------------------->
<!--                           INTRODUCTION                                

 The Code Project article submission template (HTML version)

Using this template will help us post your article sooner. To use, just 
follow the 3 easy steps below:
 
     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets. 

-->
<!--------------------------------------------------------------------------->
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
 <title>The Code Project</title>
 <style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
</style>
 <link rel="stylesheet" type="text/css" href="http://www.codeproject.com/styles/global.css">
</head>
<body bgcolor="#FFFFFF" color="#000000">
 <!--------------------------------------------------------------------------->
 <!-------------------------------     STEP 1      --------------------------->
 <!--  Fill in the details (CodeProject will reformat this section for you) -->
 <pre lang="cs">Title:       Automating VMWare Tasks in C# with VIX API
Author:      Daniel Doubrovkine
Email:       dblock@dblock.org
Member ID:   913212
Language:    C#
Platform:    Windows
Technology:  C#, NHibernate
Level:       Advanced
Description: A practical object-level security approach
Section      Suggest a section...
SubSection   Suggest a subsection...
License:     <a href="http://www.codeproject.com/info/licenses.aspx">CPOL</a>
</pre>
 <ul class="download">
  <li><a href="Vestris.ObjectLevelSecurity.zip">Download binaries &amp; source - 25
   Kb</a></li>
 </ul>
 <!-------------------------------     STEP 3      --------------------------->
 <!--  Add the article text. Please use simple formatting (<h2>, <p> etc)   -->
 <h2>
  Introduction
 </h2>
 <p>
  This article introduces a practical and robust architecture for secure services
  within a Service Oriented Architecture (SOA) model. We will develop an implementation
  of an ACL-based authorization model with NHibernate, at object level. Specifically,
  we will produce a discretionary access model with an NHibernate interceptor. While
  rather straightforward, this is a very powerful model that provides a robust and
  secure Data Access Layer (DAL) and a per-class/instance approach with a minimal
  amount of code.</p>
 <h2>
  Background
 </h2>
 <p>
  In a typical SOA architecture a caller is first authenticated and a security context
  is created based on the user's credentials. This context is made available through
  the duration of the request or session. Many web services will then verify whether
  this user is allowed to perform a specific action behind the web service API.</p>
 <p>
  For example, in a blogging system we would implement a method called <code>SaveBlogPost</code>
  and check whether the calling user is an authorized author and throw an exception
  when otherwise. A separate call, <code>GetBlogPost</code> would check for read permissions
  and <code>GetAllBlogPosts</code> would have to iterate through the resulting list
  and check access. This is an obvious, and, in my opinion, very cumbersome implementation.</p>
 <p>
  In contrast to a web service, a file system works with ACLs. An Access Control List
  (ACL) is a list of permissions attached to an object. In an ACL-based security model,
  when a subject requests to perform an operation on an object, the system first checks
  the list for an applicable entry in order to decide whether to proceed with the
  operation. Whether a file is accessed locally, via the network, a web service or
  COM, the ACL system is responsible for the file's security.</p>
 <p>
  How can we carry this ACL-based file system model into a web service?</p>
 <h2>
  Implementation
 </h2>
 <h3>
  Object Model
 </h3>
 <p>
  We will implement an ACL-based model with NHibernate. I have picked the following
  simple database object model for a blogging system.</p>
 <ul>
  <li>An <code>Account</code> that represents an authenticated user. In our system
   anyone can sign up, ie. create an account.</li>
  <li>A <code>Blog </code>has an account owner and a variable list of authors. In our
   system any authenticated user can create a blog.</li>
  <li>A <code>BlogAuthor</code> that represents an individual contributor or Account.
   In our system the blog owner can add or remove contributors. Contributors can opt
   out of being contributors without further verification.</li>
  <li>A <code>BlogPost</code> can be seen by everyone. The blog owner can edit all
   posts and blog authors can edit their own posts only.</li>
 </ul>
 <p>
  <img src="domainmodel.jpg" />&nbsp;</p>
 <p>
  We want to find a programming model where we can represent the above-mentioned authorization
  requirements in C# code. The latter can be easily extended to a configuration-based
  model where permissions are described in XML files, which is beyond the scope of
  this article.</p>
 <h3>
  NHibernate Data Layer
 </h3>
 <p>
  Getting the data in and out of the database is a trivial problem in 2009. I have
  used <a href="http://www.puzzleframework.com">Puzzle Framework</a> to design the
  domain model, export C# classes for NHibernate (both the .cs class implementations
  and the .hbm.xml NHibernate mappings) and make the UML diagram above. I've also
  added a generic <code>NHibernateCrudTest</code> unit test that ensures that all
  CRUD operations (create, retrieve, update and delete) can be made. This is the DAL,
  without any access control.</p>
 <p>
  Here's an example of a <code>Blog</code> class. I have modified the Account property
  to disallow any update, otherwise this is Puzzle-generated code. This is a way of
  disallowing ownership change for a blog by design.</p>
 <pre lang="cs">public class Blog: IDataObject
{
    private System.Int32 _Id;
    private Account _Account;
    private System.Collections.Generic.IList<blogauthor> _BlogAuthors;
    private System.Collections.Generic.IList<BlogPost> _BlogPosts;
    private System.DateTime _Created;
    private System.String _Description;
    private System.String _Name;

    public virtual System.Int32 Id { get { return _Id; } }

    public virtual Account Account
    {
        get { return _Account; }
        set
        {
            if (_Account != null)
            {
                throw new InvalidOperationException();
            }

            _Account = value;
        }
    }

    public virtual System.Collections.Generic.IList<BlogAuthor> BlogAuthors
    {
        get { return _BlogAuthors; }
        set { _BlogAuthors = value; }
    }

    public virtual System.Collections.Generic.IList<BlogPost> BlogPosts
    {
        get { return _BlogPosts; }
        set { _BlogPosts = value; }
    }

    public virtual System.DateTime Created
    {
        get { return _Created; }
        set { _Created = value; }
    }

    public virtual System.String Description
    {
        get { return _Description; }
        set { _Description = value; }
    }

    public virtual System.String Name
    {
        get { return _Name; }
        set { _Name = value; }
    }
}
  </pre>
 The following NHibernate mapping is auto-generated for a <code>Blog</code> class.
 <pre lang="xml">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" schema="dbo"&gt;
  &lt;class name="Vestris.Data.NHibernate.Blog, Data.NHibernate" table="Blog"&gt;
    &lt;id name="Id" type="Int32" column="Blog_Id" access="field.pascalcase-underscore"&gt;
      &lt;generator class="identity" /&gt;
    &lt;/id&gt;
    &lt;many-to-one name="Account" column="Account_Id" class="Vestris.Data.NHibernate.Account, Data.NHibernate" /&gt;
    &lt;bag name="BlogAuthors" inverse="true"&gt;
      &lt;key column="Blog_Id" /&gt;
      &lt;one-to-many class="Vestris.Data.NHibernate.BlogAuthor, Data.NHibernate" /&gt;
    &lt;/bag&gt;
    &lt;bag name="BlogPosts" inverse="true"&gt;
      &lt;key column="Blog_Id" /&gt;
      &lt;one-to-many class="Vestris.Data.NHibernate.BlogPost, Data.NHibernate" /&gt;
    &lt;/bag&gt;
    &lt;property name="Created" column="Created" type="DateTime" /&gt;
    &lt;property name="Description" column="Description" type="String" /&gt;
    &lt;property name="Name" column="Name" type="String" /&gt;
  &lt;/class&gt;
&lt;/hibernate-mapping&gt;
  </pre>
 <h3>
  NHibernate Interceptor
 </h3>
 <p>
  Since our goal is to do authorization at the lowest level possible and at object
  level we must intercept access to all objects above or below the DAL. An obvious
  choice is to warp every class in the DAL with a class that implements authentication,
  but NHibernate offers a much more compelling model by using a class that implements
  <code>IInterceptor</code>. The <code>IInterceptor</code> interface defines a virtual
  hook into the CRUD functions. An empty implementation, <code>NHibernate.EmptyInterceptor</code>,
  is also available and can be derived from in order to implement some, rather than
  all methods. For example, we can now witness the lifetime of all objects on the
  console.</p>
 <pre lang="cs">public class ServiceDataInterceptor : EmptyInterceptor
{
    // save an existing instance (flush dirty data)
    public override bool OnFlushDirty(object entity, object id, object[] currentState, object[] previousState, string[] propertyNames, NHibernate.Type.IType[] types)
    {
        Console.WriteLine("FlushDirty: {0}:{1}", entity, id);
        return base.OnFlushDirty(entity, id, currentState, previousState, propertyNames, types);
    }

    // save a new instance
    public override bool OnSave(object entity, object id, object[] state, string[] propertyNames, NHibernate.Type.IType[] types)
    {
        Console.WriteLine("Save: {0}:{1}", entity, id);
        return base.OnSave(entity, id, state, propertyNames, types);
    }

    // load an existing instance
    public override bool OnLoad(object entity, object id, object[] state, string[] propertyNames, NHibernate.Type.IType[] types)
    {
        Console.WriteLine("Load: {0}:{1}", entity, id);
        return base.OnLoad(entity, id, state, propertyNames, types);
    }

    // delete an existing instance
    public override void OnDelete(object entity, object id, object[] state, string[] propertyNames, NHibernate.Type.IType[] types)
    {
        Console.WriteLine("Delete: {0}:{1}", entity, id);
        base.OnDelete(entity, id, state, propertyNames, types);
    }
}    
   </pre>
 An interceptor is hooked-up to a session factory when the latter is manufactured.
 <pre lang="cs">public ISessionFactory GetSessionFactory()
{
    Configuration cfg = new Configuration();
    cfg.Properties.Add("hibernate.dialect", "NHibernate.Dialect.MsSql2000Dialect");
    cfg.Properties.Add("hibernate.connection.provider", "NHibernate.Connection.DriverConnectionProvider");
    cfg.Properties.Add("hibernate.connection.driver_class", "NHibernate.Driver.SqlClientDriver");
    cfg.Properties.Add("hibernate.connection.connection_string", "...");
    cfg.Interceptor = new ServiceDataInterceptor();
    cfg.AddAssembly("...");
    return cfg.BuildSessionFactory();
}
   </pre>
 <h3>
  User Identity
 </h3>
 <p>
  Before we implement any actual authorization we must answer two basic questions:
  what defines a user and how can we create and carry a security context throughout
  a session?</p>
 <p>
  In this system a user needs to be created first, adding a row to the Account table.
  I chose to implement an <code>IdentityService</code> that can log-in a user by looking
  up this record. This service could be easily replaced with another authentication
  scheme that, for example, logs in a user to Active Directory, then locates a record
  in the <code>Account</code> table based on the SID. For demonstration purposes both
  the security context and the identity service are rudimentary, in the "real world"
  this should be a robust interface-based and pluggable provider implementation.</p>
 <pre lang="cs">public class UserContext : EmptySessionContext
{
    private int _accountId = 0;
    private DateTime _timestamp = DateTime.UtcNow;
    public int AccountId { get { return _accountId; } }
    public DateTime TimeStamp { get { return _timestamp; } }

    protected UserContext(ISession session)
        : base(session)
    {

    }

    public UserContext(ISession session, Account account)
        : base(session)
    {
        _accountId = account.Id;
    }
}
  </pre>
 <pre lang="cs">public class IdentityService
{
    private ISession _session = null;

    public IdentityService(ISession session)
    {
        _session = session;
    }

    public UserContext Login(string username, string password)
    {
        Account account = _session.CreateCriteria(typeof(Account))
            .Add(Expression.Eq("Name", username))
            .Add(Expression.Eq("Password", password))
            .UniqueResult&lt;Account&gt;();

        if (account == null)
        {
            throw new AccessDeniedException();
        }

        return new UserContext(_session, account);
    }
}
  </pre>
 <p>
  The manufactured security context must now be made available through the lifetime
  of a request. The web services model typically exposes a singleton SessionManager.
  We will need a similar foundation for non-web-based unit tests, possibly 
  thread-safe.</p>
 <pre lang="cs">public abstract class SessionManager
{
    [ThreadStatic]
    private static ISession _currentSession = null;
    
    [ThreadStatic]
    private static ISessionContext _currentSessionContext = null;

    public static ISession CurrentSession
    {
        get { return _currentSession; }
        set { _currentSession = value; }
    }

    public static ISessionContext CurrentSessionContext
    {
        get { return _currentSessionContext; }
        set { _currentSessionContext = value; }
    }
}
  </pre>
 <p>
  The actual code in the attached demo pushes this further, creating a 
  SessionSource that can be HTTP or thread-based depending on the current 
  execution context. This enables a seamless integration in various threading or 
  pipeline requirements based on <a href="http://wiki.nhibernate.org/display/NH/Using+NHibernate+with+ASP.Net">this idea</a>.</p>
 <p>
  The pipeline (eg. NUnit or ASP.NET) will initialize the session manager with the appropriate pipeline context 
  (http vs. thread) and a data interceptor. Subsequently, it will 
  manufacture the logged-in user context and any future code, including the 
  interceptor performing the data authorization tasks, can obtain
 <code>SessionManager.CurrentSessionContext</code> to work with.
  The following code initializes SessionManager under NUnit.</p>
  <pre lang="cs">
SessionManager.Initialize(new ThreadSessionSource(), new ServiceDataInterceptor()); 
SessionManager.CurrentSessionContext = new GuestUserContext(Session);  </pre>
 <h3>
  Access Control Lists<p>
  An Access Control List (ACL) is a list of permissions attached to an object. Each
  entry defines a <code>DataOperationPermission</code> (a type of data access allowed
  or denied) for a type of <code>DataOperation</code>. An ACL can then render a verdict
  on whether the calling user may or may not access the object to which the ACL is
  attached to.
 </p>
 <p>
  <pre lang="cs">public enum DataOperation
{
    None = 0,
    Create = 1,
    Retreive = 2,
    Update = 4,
    Delete = 8,
    All = Create | Retreive | Update | Delete,
    AllExceptCreate = Retreive | Update | Delete,
    AllExceptUpdate = Create | Retreive | Delete,
    AllExceptDelete = Create | Retreive | Update
}

public enum DataOperationPermission
{
    Deny,
    Allow,
}
      
public enum ACLVerdict
{
    None,
    Denied,
    Allowed
}

public interface IACLEntry
{
    ACLVerdict Apply(UserContext ctx, DataOperation op);
}
   </pre>
 <p>
  Does it seem that this should be a boolean <code>Allowed</code> or <code>Denied</code>
  thing? Consider an ACL entry that says that an <code>Account</code> has read access
  to a <code>Blog</code>. This says nothing about whether another account has access
  to the same blog, producing a <code>None</code> verdict. In a system that denies
  access by default (an ACL must allow access explicitly), a <code>None</code> verdict
  over all entries in an ACL means that access is denied.
 </p>
 <p>
  With a base <code>ACLBaseEntry</code>, we can specialize a number of ACL entries,
  including <code>ACLEveryoneAllowRetrieve</code>, <code>ACLEveryoneAllowCreate</code>,
  as well as a generic <code>ACLAccount</code> that assignes a specific permission
  to a specific account. Here's an example of <code>ACLEveryoneAllowRetrieve</code>.
 </p>
  <pre lang="cs">public class ACLEveryoneAllowRetrieve : ACLBaseEntry
{
    public ACLEveryoneAllowRetrieve()
        : base(DataOperation.Retreive, DataOperationPermission.Allow)
    {

    }

    public override ACLVerdict Apply(UserContext ctx, DataOperation op)
    {
        return (op == DataOperation.Retreive) ? ACLVerdict.Allowed : ACLVerdict.None;
    }
}
  </pre>
 <p>
  In general, an <code>ACL</code> is a collection of <code>ACLEntry</code> items and
  implements such methods as <code>Check</code>. The latter will throw an <code>AccessDeniedException</code>
  when the current security context <code>ctx</code> doesn't allow the caller to perform
  an action <code>op</code>.
 </p>
  <pre lang="cs">public ACLVerdict Apply(UserContext ctx, DataOperation op)
{
    ACLVerdict current = ACLVerdict.Denied;

    foreach (IACLEntry entry in _accessControlList)
    {
        ACLVerdict result = entry.Apply(ctx, op);
        switch (result)
        {
            case ACLVerdict.Denied:
                return ACLVerdict.Denied;
            case ACLVerdict.Allowed:
                current = ACLVerdict.Allowed;
                break;
        }
    }

    return current;
}

public bool TryCheck(UserContext ctx, DataOperation op)
{
    ACLVerdict result = Apply(ctx, op);
    switch (result)
    {
        case ACLVerdict.Denied:
        case ACLVerdict.None:
            return false;
    }

    return true;
}

public void Check(UserContext ctx, DataOperation op)
{
    if (!TryCheck(ctx, op))
    {
        throw new AccessDeniedException();
    }
}
   </pre>
 <h3>
  Applying ACLs to Objects</h3>
 <p>
  An ACL applies to an instance of an object. For example, given a <code>Blog</code>
  we need a <code>BlogACL</code> that inherits from <code>ACL</code>. I chose a simple
  construct of manufacturing an instance of an ACL from an instance of an NHibernate
  data class via reflection, by name. The following method is implemented in the data
  interceptor and will check access when deleting any instance of <code>IDataObject</code>
  by manufacturing a <code>BlogClassACL</code> for an instance of a <code>Blog</code>.
  By using reflection I have separated authorization classes from NHibernate data,
  but it might be a good idea to implement ACL members in the auto-generated DAL and
  add ACL methods to the <code>IDataObject</code> interface.
 </p>
  <pre lang="cs">public override void OnDelete(object entity, object id, object[] state, string[] propertyNames, global::NHibernate.Type.IType[] types)
{
    if (entity is IDataObject)
    {
        Check((IDataObject)entity, DataOperation.Delete);
    }

    base.OnDelete(entity, id, state, propertyNames, types);
}
   
private void Check(IDataObject instance, DataOperation op)
{
    string aclClassTypeName = string.Format("Vestris.Service.Data.{0}ClassACL", instance.GetType().Name);            
    Type aclClassType = Assembly.GetExecutingAssembly().GetType(aclClassTypeName, true, false);
    object[] args = { instance };
    ACL acl = (ACL) Activator.CreateInstance(aclClassType, args);
    acl.Check(CurrentUserContext, op);
}
   </pre>
 <p>
  The implementation of <code>BlogClassACL</code> is meant to be trivial: we will
  have to develop a ClassACL for each data type.
 </p>
  <pre lang="cs">public class BlogClassACL : ACL
{
    public BlogClassACL(Blog instance)
    {
        // allow every authenticated user to create a blog
        this.Add(new ACLAuthenticatedAllowCreate());
        // allow everyone to get information about this blog
        this.Add(new ACLEveryoneAllowRetrieve());
        // the owner has full privileges
        this.Add(new ACLAccount(instance.Account, DataOperation.All));
    }
}
   </pre>
 <p>
  The above code demonstrates immediate advantages: the implementor has access to the actual
  object and can derive an ACL from it. It is very readable and describes naturally
  who has access to an instance of a <code>Blog</code> in exchange of a small performance
  penalty. In addition, it is possible to "inherit" ACLs as in the following example
  of a <code>BlogPostClassACL</code>.
 </p>
  <pre lang="cs">public class BlogPostClassACL : ACL
{
    public BlogPostClassACL(BlogPost instance)
    {
        // posts have the same permissions as the blog
        this.Add(new BlogClassACL(instance.Blog));
        // allow the author of the post to do everything with the post
        this.Add(new ACLAccount(instance.Account, DataOperation.AllExceptCreate));
        // allow blog authors to create posts
        if (instance.Blog.BlogAuthors != null)
        {
            foreach (BlogAuthor author in instance.Blog.BlogAuthors)
            {
                this.Add(new ACLAccount(author.Account, DataOperation.Create));
            }
        }
    }
}    
   </pre>
 You have to be careful with inehritance. The above code is actually wrong. The 
 blog&#39;s ACL allows any authenticated user to create a blog. Inheriting the ACL 
 means that any user can create a post, which is incorrect - only blog owner or 
 blog authors can create posts.<h2>Web Services</h2>
 <p>
  TODO
 </p>
 <h2>
  Source Code and Patches</h2>
 <p>
  The latest version of this article and source code can always be found in <a href="http://subversion.tigris.org/">
   Subversion</a> under <a href="svn://svn.vestris.com/codeproject/ObjectLevelSecurity/">
    svn://svn.vestris.com/codeproject/ObjectLevelSecurity</a>. You can also <a href="http://svn.vestris.com/listing.php?repname=Vestris+SVN&path=%2Fcodeproject%2FObjectLevelSecurity%2FSource%2F#_codeproject_ObjectLevelSecurity_Source_">
     browse the source code</a>. You can find the latest information about this project
  at <a href="http://code.dblock.org">code.dblock.org</a>.</p>
 <h2>
  History
 </h2>
 <p>
 </p>
  <li>01/21/2009: initial version
 <h2>
  License
 </h2>
 <p>
  This library, along with any associated source code and files, is published under
  the <a href="http://www.codeproject.com/info/licenses.aspx">CPOL</a> license, please
  reuse.
 </p>
 <!-------------------------------    That's it!   --------------------------->
</li>
</body>
</html>
